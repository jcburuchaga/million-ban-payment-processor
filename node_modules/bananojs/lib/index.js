const axios = require('axios')

const utils = require('./utils')

module.exports = (nodeURL, opts = {}) => {
  const instance = axios.create({
    baseURL: nodeURL,
    timeout: 5000,
    ...opts,
  })

  const execute = (action, params = {}, fn) => instance
    .post('', { action, ...params })
    .then(({ data }) => {
      console.log("instance",instance);
      console.log("data",{ action, ...params });
      if (data.error) {
        throw new Error(data.error)
      }

      return fn
        ? typeof fn === 'string'
          ? data[fn]
          : fn(data)
        : data
    })

  const getBlocksInfo = (hashes, opts = { pending: true, source: true, balance: true, json_block: true }) => execute('blocks_info', { hashes, ...opts }, data => {
    if (opts.json_block) {
      return Object.keys(data.blocks).reduce((all, hash) => ({
        ...all,
        [hash]: {
          ...data.blocks[hash],
          contents: JSON.parse(data.blocks[hash].contents),
        },
      }), {})
    }

    return data.blocks
  })

  return {
    getAccount: key => execute('account_get', { key }, 'account'),

    removeAccount: (wallet, account) => execute('account_remove', { wallet, account }, data => Boolean(parseInt(data.removed))),

    getAccountBalance: account => execute('account_balance', { account }, 'balance'),

    getAccountBalances: accounts => execute('accounts_balances', { accounts }, 'balances'),

    getAccountList: wallet => execute('account_list', { wallet }, 'accounts'),

    getAccountBlockCount: account => execute('account_block_count', { account }, 'block_count'),

    getAccountInfo: (account, opts) => execute('account_info', { account, ...opts }),

    getAccountCount: () => execute('account_count', null, 'count'),

    getAccountNumber: key => execute('account_get', { key }, 'account'),

    getAccountKey: account => execute('account_key', { account }),

    getAccountWeight: account => execute('account_weight', { account }, 'weight'),

    getAccountRepresentative: account => execute('account_representative', { account }, 'representative'),

    getAccountWeight: account => execute('account_weight', { account }, 'weight'),

    getAccountHistory: (account, opts = { count: 100, raw: true }) => execute('account_history', { account, ...opts }, 'history'),

    getPublicKey: account => execute('account_key', { account }, 'key'),

    getVersion: () => execute('version'),

    getBlock: (hash, json_block = true) => execute('block_info', { hash, json_block }, data => {
      if (json_block) {
        return {
          ...data,
          contents: JSON.parse(data.contents)
        }
      }

      return data
    }),

    getBlocks: hashes => execute('blocks', { hashes }, 'blocks'),

    getBlockInfo: (hash, opts) => getBlocksInfo([hash], opts)
      .then(data => data[hash]),

    getBlocksInfo,

    getAvailableSupply: () => execute('available_supply', null, 'available'),

    getBlockCount: () => execute('block_count'),

    createAccount: wallet => execute('account_create', { wallet }, 'account'),

    createWallet: (seed = utils.createSeed()) => execute('wallet_create', { seed }, data => Object.assign({}, data, { seed })),

    getWalletInfo: wallet => execute('wallet_info', { wallet }),

    getWalletHistory: wallet => execute('wallet_history', { wallet }, 'history'),

    send: (wallet, source, destination, amount, id) => execute('send', { wallet, source, destination, amount, id }),

    receive: (wallet, account, block) => execute('receive', { wallet, account, block }),

    banToRaw: amount => execute('ban_to_raw', { amount: amount.toString() }, 'amount'),

    rawToBan: amount => execute('ban_from_raw', { amount }, 'amount'),

    getUptime: () => execute('uptime'),

    getDelegators: account => execute('delegators', { account }, 'delegators'),

    getDelegatorsCount: account => execute('delegators_count', { account }, 'count'),

    getDeterministicKey: (seed, index = 0) => execute('deterministic_key', { seed, index }),

    getFrontiers: (account, count = 1) => execute('frontiers', { account, count }, 'frontiers'),

    getFrontiersCount: () => execute('frontier_count', null, 'count'),

    createKey: () => execute('key_create'),

    expandKey: key => execute('key_expand', { key }),

    getReceiveMinimum: () => execute('receive_minimum', null, 'amount'),

    getPendingBlocks: wallet => wallet
      ? execute('search_pending', { wallet }, 'started')
      : execute('search_pending_all'),

    signBlockWithKey: (key, block) => execute('sign', { key, block }),

    signBlockWithWalletAndAccount: (wallet, account) => execute('sign', { key, block }),

    getPeers: () => execute('peers', null, 'peers'),

    getPendingBlocksForAccount: (account, count = 10, threshold = 0, source = false) => execute('pending', { account, count, threshold, source }, 'blocks'),

    isBlockPending: hash => execute('pending_exists', { hash }, data => Boolean(parseInt(data.exists))),

    getWalletBalances: wallet => execute('wallet_balances', { wallet }, 'balances'),

    changeWalletSeed: (wallet, seed) => execute('wallet_change_seed', { wallet, seed }),

    walletContains: (wallet, account) => execute('wallet_contains', { wallet, account }, data => Boolean(parseInt(data.exists))),

    generateWorkForBlock: (hash, use_peers = false) => execute('work_generate', { hash, use_peers }, 'work'),

    getWork: (wallet, account) => execute('work_get', { wallet, account }, 'work'),

    rpc: ({ action, transform, ...rest }) => execute(action, rest, transform),

    utils,
  }
}
